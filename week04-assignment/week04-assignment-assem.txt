week04-assignment

   0x0000000000001129 <+0>:	endbr64 
   0x000000000000112d <+4>:	push   %rbp // stack frame을 설정하기 위해 rbp를 스텍에 넣는다
   0x000000000000112e <+5>:	mov    %rsp,%rbp // rsp레지스터값을 rbp레지스터에 대입
   0x0000000000001131 <+8>:	movl   $0x1,-0x4(%rbp) //  0x1 값이 %rbp 레지스터의 4바이트 아래에 위치한 메모리 영역에 저장 => 1할당 // a=1;
   0x0000000000001138 <+15>:	cmpl   $0x2,-0x4(%rbp) // 0x2 값과 %rbp 레지스터의 4바이트 아래에 위치한 메모리 영역의 값을 비교 => 2랑 비교

   0x000000000000113c <+19>:	je     0x115e <main+53> // %rbp 레지스터의 4바이트 아래에 위치한 메모리 영역의 값이 0x2일 경우, 0x115e 주소로 이동 => 같으면 main+53으로 이동
   0x000000000000113e <+21>:	cmpl   $0x2,-0x4(%rbp) // 0x2 값과 %rbp레지스터의 4바이트 아래에 위치한 메모리 영역의 값을 비교
   0x0000000000001142 <+25>:	jg     0x1165 <main+60> // 만약 비교 결과가 더 크면 0x1165(main+60)으로 이동 => default 
   0x0000000000001144 <+27>:	cmpl   $0x0,-0x4(%rbp) // 0x0 값이 %rbp 레지스터의 4바이트 아래에 위치한 메모리 영역의 값을 비교
   0x0000000000001148 <+31>:	je     0x1152 <main+41> // 값 비교 후 같으면 0x1152(main+41) 이동 => case 0
   0x000000000000114a <+33>:	cmpl   $0x1,-0x4(%rbp) // 0x1 값이 %rbp 레지스터의 4바이트 아래에 위치한 메모리 영역의 값을 비교
   0x000000000000114e <+37>:	je     0x1158 <main+47> // 비교했을때 같으면 0x1158(main+47)로 이동 => case 1
   0x0000000000001150 <+39>:	jmp    0x1165 <main+60> // 그렇지 않으면 0x1165(main+60)으로 이동 => default
   0x0000000000001152 <+41>:	addl   $0x1,-0x4(%rbp) // %rbp 레지스터의 4바이트 아래에 위치한 메모리 영역의 값에 0x1을 더함 => case 0
   0x0000000000001156 <+45>:	jmp    0x116d <main+68> // 0x116d(main+68)로 이동
   0x0000000000001158 <+47>:	subl   $0x1,-0x4(%rbp) // %rbp 레지스터의 4바이트 아래에 위치한 메모리 영역의 값에 0x1을 뺌 => case 1
   0x000000000000115c <+51>:	jmp    0x116d <main+68> // 0x116d(main+68)로 이동
   0x000000000000115e <+53>:	movl   $0x0,-0x4(%rbp) // %rbp 레지스터의 4바이트 아래에 위치한 메모리 영역의 값에 0x0을 대입 => case 2
   0x0000000000001165 <+60>:	movl   $0x64,-0x4(%rbp) // 100을 할당
   0x000000000000116c <+67>:	nop   // alignment ... 
   0x000000000000116d <+68>:	mov    $0x0,%eax // eax에 0x0을 대입
   0x0000000000001172 <+73>:	pop    %rbp // 함수의 stack frame을 정리, stack 상단의 값을 rbp 레지스터에 복원하는 명령어, stack pointer 증가
   0x0000000000001173 <+74>:	ret    // 함수 호출이 끝났음을 나타냄. 현재 스택 프레임에서 반환 주소를 가져와 그 위치로 점프함. eax레지스터에 0을 저장 후 이전 rbp를 복원후 점프=> return 0;    

cat > switch.c
gcc -g switch.c -masm=intel
gdb -q a.out

#include <stdio.h>
int main(void)
{
  int a = 1;
  switch( a )
  {
    case 0:
      a++;
			break;
    case 1:
			a--;
      break;
    case 2:
			a = 0;
    default:
      a = 100;
      break;
  }
  return 0;
}

case 2를 제외하고 break 를 해주었다.

endbr64 명령어는 인스트럭션 세트 확장 (Instruction Set Extension) 으로, 
인스트럭션 세트의 일부인 BMI2(BIT Manipulation Instructions Set 2)에서 추가된 명령어이다. 이는 코드 실행시 사용될 인스트럭션 세트를 설정한다.

movl 명령어는 32비트 정수형 값을 레지스터나 메모리 영역에 대입하는 명령어이다.
cmpl 명령어는 32비트 정수형 값을 비교하는 명령어이다.
je 명령어는 이전에 수행한 비교 연산이 참일 경우, 지정된 주소로 이동하는 명령어이다.
jg 명령어는 비교 연산 결과가 양수(즉, 첫 번째 피연산자가 두 번째 피연산자보다 큰 경우)이면 주어진 주소로 분기하는 명령어이다.

흐름은 다음과 같다

endbr64에서 컴파일러가 추가한 보안관련 명령어
push rbp에서 현재 스택 프레임의 베이스 포인터 스택에 저장 후 movl $0x1,-0x4(%rbp 에서 부터 시작이다.
이어지는 조건문들을 통해 rbp-4의 값을 비교하고 비교 결과에 따라 값을 정한다
4번째 줄은 rbp-4의 저장된 값과 2를 비교 5번째 줄은 비교 결과가 같으면 0x115e로 점프 6번째 줄(cmp $0x2,-0x4(%rbp))에서는 rbp-4에 저장된 값과 2를 다시 비교하고, 
7번째 줄(jg 0x1165)에서는 비교 결과가 크면 0x1165로 점프
8번째 줄(cmp $0x0,-0x4(%rbp))에서는 rbp-4에 저장된 값과 0을 비교하고, 9번째 줄(je 0x1152)에서는 비교 결과가 같으면 0x1152로 점프, 10번째 줄(cmp $0x1,-0x4(%rbp))에서는 rbp-4에 저장된 값과 1을 비교하고
11번째 줄(je 0x1158)에서는 비교 결과가 같으면 0x1158로 점프

만약 이 조건문에서 어떤 점프도 일어나지 않으면 12번째 줄(jmp 0x1165)에서 0x1165로 점프
0x1152에서 0x1156으로 점프하는 부분에서는 rbp-4의 값을 1 증가시키고 0x1158에서 0x115c로 점프하는 부분에서는 rbp-4의 값을 1 감소시킨다.
마지막 두 줄에서는 반환값으로 0을 설정하고 스택 프레임의 베이스 포인터를 복원한 후(main 함수를 빠져나갈 때 필요) 리턴한다.